<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .results-section {
            margin-top: 2rem;
            display: none;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem;
            border-radius: 8px;
            text-align: center;
        }

        .metric-card.positive {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .metric-card.negative {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
        }

        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .metric-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .trades-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            background: white;
            border-radius: 8px;
            overflow: hidden;
        }

        .trades-table thead {
            background: #667eea;
            color: white;
        }

        .trades-table th,
        .trades-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }

        .trades-table tbody tr:hover {
            background: #f5f5f5;
        }

        .trades-table tbody tr:last-child td {
            border-bottom: none;
        }

        .pnl-positive {
            color: #11998e;
            font-weight: 600;
        }

        .pnl-negative {
            color: #eb3349;
            font-weight: 600;
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .badge-buy {
            background: #11998e;
            color: white;
        }

        .badge-sell {
            background: #eb3349;
            color: white;
        }

        .badge-target {
            background: #38ef7d;
            color: #333;
        }

        .badge-stop {
            background: #f45c43;
            color: white;
        }

        .badge-eod {
            background: #667eea;
            color: white;
        }

        .chart-container {
            margin: 2rem 0;
            padding: 1.5rem;
            background: white;
            border-radius: 8px;
        }

        .candle-chart-container {
            margin: 2rem 0;
            padding: 1.5rem;
            background: white;
            border-radius: 8px;
            display: none;
        }

        .candle-chart-container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9999;
            margin: 0;
            padding: 1.5rem;
            border-radius: 0;
            background: white;
            overflow: auto;
        }

        .candle-chart-wrapper {
            position: relative;
            width: 100%;
            height: 600px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .candle-chart-container.fullscreen .candle-chart-wrapper {
            height: calc(100vh - 200px);
            min-height: 500px;
        }

        #candleChartCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .chart-controls {
            margin-bottom: 1rem;
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn-fullscreen {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn-fullscreen:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(17, 153, 142, 0.4);
        }

        .btn-fullscreen:active {
            transform: translateY(0);
        }

        .btn-show-chart {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn-show-chart:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-show-chart:active {
            transform: translateY(0);
        }

        .trade-selector {
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9rem;
            flex: 1;
            min-width: 200px;
        }

        .chart-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 1rem;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #333;
        }

        .best-worst-trades {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        .trade-detail-card {
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .trade-detail-card.best {
            border-left-color: #11998e;
        }

        .trade-detail-card.worst {
            border-left-color: #eb3349;
        }

        .trade-detail-card h4 {
            margin-bottom: 0.5rem;
            color: #333;
        }

        .trade-detail-card p {
            margin: 0.25rem 0;
            color: #666;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .metrics-grid {
                grid-template-columns: 1fr;
            }

            .best-worst-trades {
                grid-template-columns: 1fr;
            }

            .trades-table {
                font-size: 0.85rem;
            }

            .trades-table th,
            .trades-table td {
                padding: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <h1 class="card-title">Breakout Strategy Backtest</h1>
            <p class="card-subtitle">Run an intraday breakout strategy using previous day high/low breakouts</p>

            <!-- Success Message -->
            <div id="successMessage" class="alert alert-success" style="display: none;"></div>

            <!-- Error Message -->
            <div id="errorMessage" class="alert alert-error" style="display: none;"></div>

            <!-- Loading Message -->
            <div id="loadingMessage" class="alert alert-info" style="display: none;">
                <div class="spinner"></div>
                <span>Running strategy backtest... This may take a few moments.</span>
            </div>

            <form id="strategyForm" class="form">
                <div class="form-group">
                    <label for="stockName">Stock Name <span class="required">*</span></label>
                    <input 
                        type="text" 
                        id="stockName" 
                        name="stockName" 
                        class="form-control" 
                        placeholder="e.g., RELIANCE"
                        value="RELIANCE"
                        required
                    >
                    <small class="form-text">Enter the stock name</small>
                </div>

                <div class="form-group">
                    <label for="securityId">Security ID <span class="required">*</span></label>
                    <input 
                        type="text" 
                        id="securityId" 
                        name="securityId" 
                        class="form-control" 
                        placeholder="e.g., 2885"
                        value="2885"
                        required
                    >
                    <small class="form-text">Dhan Security ID for the stock</small>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="startDate">Start Date <span class="required">*</span></label>
                        <input 
                            type="date" 
                            id="startDate" 
                            name="startDate" 
                            class="form-control" 
                            required
                        >
                    </div>

                    <div class="form-group">
                        <label for="endDate">End Date <span class="required">*</span></label>
                        <input 
                            type="date" 
                            id="endDate" 
                            name="endDate" 
                            class="form-control" 
                            required
                        >
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="targetPercent">Target Percent <span class="required">*</span></label>
                        <input 
                            type="number" 
                            id="targetPercent" 
                            name="targetPercent" 
                            class="form-control" 
                            step="0.01"
                            min="0.01"
                            max="10"
                            value="0.2"
                            required
                        >
                        <small class="form-text">Target profit percentage (e.g., 0.2 for 0.2%)</small>
                    </div>

                    <div class="form-group">
                        <label for="stopLossPercent">Stop Loss Percent <span class="required">*</span></label>
                        <input 
                            type="number" 
                            id="stopLossPercent" 
                            name="stopLossPercent" 
                            class="form-control" 
                            step="0.01"
                            min="0.01"
                            max="10"
                            value="0.2"
                            required
                        >
                        <small class="form-text">Stop loss percentage (e.g., 0.2 for 0.2%)</small>
                    </div>
                </div>

                <div class="form-group">
                    <label for="capital">Initial Capital <span class="required">*</span></label>
                    <input 
                        type="number" 
                        id="capital" 
                        name="capital" 
                        class="form-control" 
                        step="1000"
                        min="1000"
                        value="100000"
                        required
                    >
                    <small class="form-text">Starting capital amount (e.g., 100000 for ‚Çπ1,00,000)</small>
                </div>

                <button type="submit" class="btn btn-primary" id="submitBtn">
                    Run Strategy Backtest
                </button>
            </form>

            <!-- Results Section -->
            <div id="resultsSection" class="results-section">
                <h2 class="section-title">Backtest Results</h2>

                <!-- Strategy Parameters -->
                <div id="strategyParams" style="margin-bottom: 2rem; padding: 1rem; background: #f8f9fa; border-radius: 8px;">
                    <h3 style="font-size: 1rem; margin-bottom: 0.5rem; color: #666;">Strategy Parameters</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; font-size: 0.9rem;">
                        <div><strong>Target:</strong> <span id="configTargetPercent"></span></div>
                        <div><strong>Stop Loss:</strong> <span id="configStopLossPercent"></span></div>
                    </div>
                </div>

                <!-- Performance Metrics -->
                <div class="metrics-grid" id="metricsGrid"></div>

                <!-- Best and Worst Trades -->
                <div id="bestWorstTrades"></div>

                <!-- Capital Analytics -->
                <div class="chart-container">
                    <h3 class="section-title">Capital Analytics</h3>
                    <div id="capitalMetrics" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;"></div>
                    <canvas id="capitalChart"></canvas>
                </div>

                <!-- P&L Chart -->
                <div class="chart-container">
                    <h3 class="section-title">Cumulative P&L Chart</h3>
                    <canvas id="pnlChart"></canvas>
                </div>

                <!-- Show Chart Button -->
                <div style="margin: 2rem 0; text-align: center;">
                    <button class="btn-show-chart" id="showChartsBtn" onclick="showChartsView()" style="display: none;">
                        üìä Show Trade Charts
                    </button>
                </div>

                <!-- Trades Table -->
                <div>
                    <h3 class="section-title">Trade Details</h3>
                    <div style="overflow-x: auto;">
                        <table class="trades-table" id="tradesTable">
                            <thead>
                                <tr>
                                    <th>Date</th>
                                    <th>Type</th>
                                    <th>Entry Price</th>
                                    <th>Exit Price</th>
                                    <th>Quantity</th>
                                    <th>P&L</th>
                                    <th>P&L %</th>
                                    <th>Exit Reason</th>
                                    <th>Chart</th>
                                </tr>
                            </thead>
                            <tbody id="tradesTableBody"></tbody>
                        </table>
                    </div>
                </div>

                <!-- Candle Chart Section -->
                <div class="candle-chart-container" id="candleChartContainer">
                    <div class="chart-controls">
                        <button class="btn-show-chart" id="closeChartBtn" onclick="closeCandleChart()">Close Chart</button>
                        <button class="btn-fullscreen" id="fullscreenBtn" onclick="toggleFullscreen()">‚õ∂ Fullscreen</button>
                        <select class="trade-selector" id="tradeSelector" onchange="loadTradeChart()">
                            <option value="">Select a trade to view chart...</option>
                        </select>
                    </div>
                    <h3 class="section-title" id="chartTitle">Candle Chart</h3>
                    <div class="candle-chart-wrapper">
                        <canvas id="candleChartCanvas"></canvas>
                    </div>
                    <div class="chart-legend" id="chartLegend"></div>
                </div>
            </div>

            <div class="back-link">
                <a href="/">‚Üê Back to Home</a>
            </div>
        </div>
    </div>

    <script>
        // Set max date to today
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('endDate').setAttribute('max', today);
        document.getElementById('startDate').setAttribute('max', today);

        // Set default dates (last 30 days)
        const defaultEndDate = new Date();
        const defaultStartDate = new Date();
        defaultStartDate.setDate(defaultStartDate.getDate() - 30);
        document.getElementById('endDate').value = defaultEndDate.toISOString().split('T')[0];
        document.getElementById('startDate').value = defaultStartDate.toISOString().split('T')[0];

        // Form elements
        const form = document.getElementById('strategyForm');
        const submitBtn = document.getElementById('submitBtn');
        const successMessage = document.getElementById('successMessage');
        const errorMessage = document.getElementById('errorMessage');
        const loadingMessage = document.getElementById('loadingMessage');
        const resultsSection = document.getElementById('resultsSection');
        let pnlChart = null;
        let capitalChart = null;
        let allTradesData = null; // Store all trades data
        let globalConfig = null; // Store config globally

        // Hide messages function
        function hideMessages() {
            successMessage.style.display = 'none';
            errorMessage.style.display = 'none';
            loadingMessage.style.display = 'none';
        }

        // Show error function
        function showError(message) {
            hideMessages();
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
            errorMessage.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        // Show loading function
        function showLoading() {
            hideMessages();
            loadingMessage.style.display = 'block';
            submitBtn.disabled = true;
            submitBtn.textContent = 'Running...';
            resultsSection.style.display = 'none';
        }

        // Hide loading function
        function hideLoading() {
            loadingMessage.style.display = 'none';
            submitBtn.disabled = false;
            submitBtn.textContent = 'Run Strategy Backtest';
        }

        // Date validation
        function validateDates(showErrorMsg = true) {
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            const startDate = startDateInput.value;
            const endDate = endDateInput.value;

            // Clear any previous error styling
            startDateInput.style.borderColor = '';
            endDateInput.style.borderColor = '';

            if (!startDate || !endDate) {
                if (showErrorMsg) {
                    showError('Please select both start and end dates');
                }
                return false;
            }

            const start = new Date(startDate);
            const end = new Date(endDate);

            if (isNaN(start.getTime()) || isNaN(end.getTime())) {
                if (showErrorMsg) {
                    showError('Invalid date format');
                }
                return false;
            }

            if (start >= end) {
                if (showErrorMsg) {
                    showError('End date must be after start date');
                    endDateInput.style.borderColor = '#e74c3c';
                }
                return false;
            }

            return true;
        }

        // Add date change listeners (without showing error on every change)
        document.getElementById('startDate').addEventListener('change', function() {
            validateDates(false); // Validate but don't show error on change
        });
        document.getElementById('endDate').addEventListener('change', function() {
            validateDates(false); // Validate but don't show error on change
        });

        // Format currency
        function formatCurrency(value) {
            return `‚Çπ${value.toFixed(2)}`;
        }

        // Format percentage
        function formatPercent(value) {
            return `${value.toFixed(2)}%`;
        }

        // Display results
        function displayResults(data) {
            const { config, summary, trades } = data;
            
            // Store data globally
            allTradesData = trades;
            globalConfig = config;

            // Display strategy parameters
            document.getElementById('configTargetPercent').textContent = `${config.targetPercent}%`;
            document.getElementById('configStopLossPercent').textContent = `${config.stopLossPercent}%`;

            // Display metrics
            const metricsGrid = document.getElementById('metricsGrid');
            metricsGrid.innerHTML = `
                <div class="metric-card">
                    <div class="metric-value">${summary.totalTrades}</div>
                    <div class="metric-label">Total Trades</div>
                </div>
                <div class="metric-card ${summary.winRate >= 50 ? 'positive' : 'negative'}">
                    <div class="metric-value">${summary.winRate}%</div>
                    <div class="metric-label">Win Rate</div>
                </div>
                <div class="metric-card ${summary.totalPnl >= 0 ? 'positive' : 'negative'}">
                    <div class="metric-value">${formatCurrency(summary.totalPnl)}</div>
                    <div class="metric-label">Total P&L</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${formatCurrency(summary.averagePnl)}</div>
                    <div class="metric-label">Avg P&L per Trade</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${summary.winningTrades}</div>
                    <div class="metric-label">Winning Trades</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${summary.losingTrades}</div>
                    <div class="metric-label">Losing Trades</div>
                </div>
                <div class="metric-card ${summary.maxDrawdown === 0 ? 'positive' : 'negative'}">
                    <div class="metric-value">${formatCurrency(summary.maxDrawdown)}</div>
                    <div class="metric-label">Max Drawdown</div>
                </div>
            `;

            // Display best and worst trades
            const bestWorstTrades = document.getElementById('bestWorstTrades');
            if (summary.bestTrade || summary.worstTrade) {
                let html = '<div class="best-worst-trades">';
                
                if (summary.bestTrade) {
                    const t = summary.bestTrade;
                    html += `
                        <div class="trade-detail-card best">
                            <h4>üèÜ Best Trade</h4>
                            <p><strong>Type:</strong> <span class="badge badge-${t.type.toLowerCase()}">${t.type}</span></p>
                            <p><strong>Entry:</strong> ${formatCurrency(t.entryPrice)} at ${new Date(t.entryTime).toLocaleString()}</p>
                            <p><strong>Exit:</strong> ${formatCurrency(t.exitPrice)} at ${new Date(t.exitTime).toLocaleString()}</p>
                            <p><strong>P&L:</strong> <span class="pnl-positive">${formatCurrency(t.pnl)} (${formatPercent(t.pnlPercent)})</span></p>
                            <p><strong>Exit Reason:</strong> <span class="badge badge-${t.exitReason.toLowerCase().replace('_', '-')}">${t.exitReason}</span></p>
                        </div>
                    `;
                }

                if (summary.worstTrade) {
                    const t = summary.worstTrade;
                    html += `
                        <div class="trade-detail-card worst">
                            <h4>üìâ Worst Trade</h4>
                            <p><strong>Type:</strong> <span class="badge badge-${t.type.toLowerCase()}">${t.type}</span></p>
                            <p><strong>Entry:</strong> ${formatCurrency(t.entryPrice)} at ${new Date(t.entryTime).toLocaleString()}</p>
                            <p><strong>Exit:</strong> ${formatCurrency(t.exitPrice)} at ${new Date(t.exitTime).toLocaleString()}</p>
                            <p><strong>P&L:</strong> <span class="pnl-negative">${formatCurrency(t.pnl)} (${formatPercent(t.pnlPercent)})</span></p>
                            <p><strong>Exit Reason:</strong> <span class="badge badge-${t.exitReason.toLowerCase().replace('_', '-')}">${t.exitReason}</span></p>
                        </div>
                    `;
                }

                html += '</div>';
                bestWorstTrades.innerHTML = html;
            }

            // Populate trade selector
            const tradeSelector = document.getElementById('tradeSelector');
            tradeSelector.innerHTML = '<option value="">Select a trade to view chart...</option>' +
                trades.map((trade, index) => 
                    `<option value="${index}">${trade.date} - ${trade.type} - ${formatCurrency(trade.pnl)}</option>`
                ).join('');

            // Display trades table
            const tradesTableBody = document.getElementById('tradesTableBody');
            tradesTableBody.innerHTML = trades.map((trade, index) => {
                const pnlClass = trade.pnl >= 0 ? 'pnl-positive' : 'pnl-negative';
                const exitReasonClass = trade.exitReason.toLowerCase().replace('_', '-');
                const quantity = trade.quantity || 1; // Fallback to 1 if quantity not present
                return `
                    <tr>
                        <td>${trade.date}</td>
                        <td><span class="badge badge-${trade.type.toLowerCase()}">${trade.type}</span></td>
                        <td>${formatCurrency(trade.entryPrice)}</td>
                        <td>${formatCurrency(trade.exitPrice)}</td>
                        <td>${quantity}</td>
                        <td class="${pnlClass}">${formatCurrency(trade.pnl)}</td>
                        <td class="${pnlClass}">${formatPercent(trade.pnlPercent)}</td>
                        <td><span class="badge badge-${exitReasonClass}">${trade.exitReason}</span></td>
                        <td><button class="btn-show-chart" style="padding: 0.5rem 1rem; font-size: 0.85rem;" onclick="showTradeChart(${index})">View Chart</button></td>
                    </tr>
                `;
            }).join('');

            // Calculate and display capital analytics
            const initialCapital = config.capital || 100000;
            let cumulativePnlForCapital = 0;
            const capitalData = trades.map((trade, index) => {
                cumulativePnlForCapital += trade.pnl;
                return {
                    x: trade.date,
                    y: initialCapital + cumulativePnlForCapital
                };
            });

            // Add initial point
            if (trades.length > 0) {
                capitalData.unshift({ x: trades[0].date, y: initialCapital });
            }

            // Calculate final capital using the cumulative P&L (more accurate)
            const finalCapital = capitalData.length > 0 ? capitalData[capitalData.length - 1].y : initialCapital;
            // Alternative: use summary.totalPnl if available and matches
            const calculatedFinalCapital = initialCapital + summary.totalPnl;
            
            // Use the more accurate value (from cumulative calculation)
            const actualFinalCapital = Math.abs(finalCapital - calculatedFinalCapital) < 0.01 ? calculatedFinalCapital : finalCapital;
            
            // Calculate capital growth percentage
            const capitalGrowth = ((actualFinalCapital - initialCapital) / initialCapital) * 100;

            // Display capital metrics
            const capitalMetrics = document.getElementById('capitalMetrics');
            capitalMetrics.innerHTML = `
                <div class="metric-card">
                    <div class="metric-value">${formatCurrency(initialCapital)}</div>
                    <div class="metric-label">Initial Capital</div>
                </div>
                <div class="metric-card ${actualFinalCapital >= initialCapital ? 'positive' : 'negative'}">
                    <div class="metric-value">${formatCurrency(actualFinalCapital)}</div>
                    <div class="metric-label">Final Capital</div>
                </div>
                <div class="metric-card ${capitalGrowth >= 0 ? 'positive' : 'negative'}">
                    <div class="metric-value">${formatPercent(capitalGrowth)}</div>
                    <div class="metric-label">Capital Growth</div>
                </div>
                <div class="metric-card ${summary.totalPnl >= 0 ? 'positive' : 'negative'}">
                    <div class="metric-value">${formatCurrency(summary.totalPnl)}</div>
                    <div class="metric-label">Total Profit/Loss</div>
                </div>
            `;

            // Create capital growth chart
            const capitalCtx = document.getElementById('capitalChart').getContext('2d');
            
            if (capitalChart) {
                capitalChart.destroy();
            }

            capitalChart = new Chart(capitalCtx, {
                type: 'line',
                data: {
                    labels: capitalData.map(d => d.x),
                    datasets: [{
                        label: 'Capital Growth',
                        data: capitalData.map(d => d.y),
                        borderColor: actualFinalCapital >= initialCapital ? '#11998e' : '#eb3349',
                        backgroundColor: actualFinalCapital >= initialCapital ? 'rgba(17, 153, 142, 0.1)' : 'rgba(235, 51, 73, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Capital: ${formatCurrency(context.parsed.y)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: {
                                callback: function(value) {
                                    return formatCurrency(value);
                                }
                            }
                        }
                    }
                }
            });

            // Create P&L chart
            let cumulativePnl = 0;
            const chartData = trades.map((trade, index) => {
                cumulativePnl += trade.pnl;
                return {
                    x: trade.date,
                    y: cumulativePnl
                };
            });

            // Add initial point at 0
            if (trades.length > 0) {
                chartData.unshift({ x: trades[0].date, y: 0 });
            }

            const ctx = document.getElementById('pnlChart').getContext('2d');
            
            if (pnlChart) {
                pnlChart.destroy();
            }

            pnlChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.map(d => d.x),
                    datasets: [{
                        label: 'Cumulative P&L',
                        data: chartData.map(d => d.y),
                        borderColor: cumulativePnl >= 0 ? '#11998e' : '#eb3349',
                        backgroundColor: cumulativePnl >= 0 ? 'rgba(17, 153, 142, 0.1)' : 'rgba(235, 51, 73, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `P&L: ${formatCurrency(context.parsed.y)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: {
                                callback: function(value) {
                                    return formatCurrency(value);
                                }
                            }
                        }
                    }
                }
            });

            // Show results section
            resultsSection.style.display = 'block';
            
            // Show the main chart button if there are trades
            if (trades.length > 0) {
                document.getElementById('showChartsBtn').style.display = 'inline-block';
            }
            
            resultsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        // Custom Candlestick Chart Functions
        function showTradeChart(tradeIndex) {
            if (!allTradesData || !allTradesData[tradeIndex]) {
                showError('Trade data not available');
                return;
            }
            const trade = allTradesData[tradeIndex];
            loadCandleChart(trade);
        }

        function loadTradeChart() {
            const tradeSelector = document.getElementById('tradeSelector');
            const tradeIndex = parseInt(tradeSelector.value);
            if (isNaN(tradeIndex) || !allTradesData || !allTradesData[tradeIndex]) {
                return;
            }
            const trade = allTradesData[tradeIndex];
            loadCandleChart(trade);
        }

        function showChartsView() {
            const chartContainer = document.getElementById('candleChartContainer');
            chartContainer.style.display = 'block';
            chartContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            const tradeSelector = document.getElementById('tradeSelector');
            if (tradeSelector.options.length > 1) {
                tradeSelector.focus();
            }
        }

        function closeCandleChart() {
            const chartContainer = document.getElementById('candleChartContainer');
            chartContainer.style.display = 'none';
            // Exit fullscreen if active
            if (chartContainer.classList.contains('fullscreen')) {
                chartContainer.classList.remove('fullscreen');
                updateFullscreenButton();
            }
        }

        function toggleFullscreen() {
            const chartContainer = document.getElementById('candleChartContainer');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            
            if (chartContainer.classList.contains('fullscreen')) {
                // Exit fullscreen
                chartContainer.classList.remove('fullscreen');
                updateFullscreenButton();
            } else {
                // Enter fullscreen
                chartContainer.classList.add('fullscreen');
                updateFullscreenButton();
            }
            
            // Redraw chart after a short delay to ensure container size is updated
            setTimeout(() => {
                const tradeSelector = document.getElementById('tradeSelector');
                const selectedIndex = parseInt(tradeSelector.value);
                if (!isNaN(selectedIndex) && allTradesData && allTradesData[selectedIndex]) {
                    loadCandleChart(allTradesData[selectedIndex]);
                }
            }, 100);
        }

        function updateFullscreenButton() {
            const chartContainer = document.getElementById('candleChartContainer');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            if (chartContainer.classList.contains('fullscreen')) {
                fullscreenBtn.textContent = '‚õ∂ Exit Fullscreen';
            } else {
                fullscreenBtn.textContent = '‚õ∂ Fullscreen';
            }
        }

        async function loadCandleChart(trade) {
            try {
                const chartContainer = document.getElementById('candleChartContainer');
                const chartTitle = document.getElementById('chartTitle');
                chartTitle.textContent = `Candle Chart - ${trade.date} (${trade.type})`;
                chartContainer.style.display = 'block';
                chartContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

                // Calculate target and stop loss
                const targetPercent = globalConfig ? globalConfig.targetPercent : parseFloat(document.getElementById('configTargetPercent').textContent.replace('%', ''));
                const stopLossPercent = globalConfig ? globalConfig.stopLossPercent : parseFloat(document.getElementById('configStopLossPercent').textContent.replace('%', ''));
                
                let target, stopLoss;
                if (trade.type === 'BUY') {
                    target = trade.entryPrice * (1 + targetPercent / 100);
                    stopLoss = trade.entryPrice * (1 - stopLossPercent / 100);
                } else {
                    target = trade.entryPrice * (1 - targetPercent / 100);
                    stopLoss = trade.entryPrice * (1 + stopLossPercent / 100);
                }

                // Get securityId
                const securityId = globalConfig ? globalConfig.securityId : document.getElementById('securityId').value;
                
                // Fetch candle data
                const response = await fetch(`/strategy/chart?securityId=${encodeURIComponent(securityId)}&date=${encodeURIComponent(trade.date)}&entryPrice=${trade.entryPrice}&exitPrice=${trade.exitPrice}&entryTime=${encodeURIComponent(trade.entryTime)}&exitTime=${encodeURIComponent(trade.exitTime)}&target=${target}&stopLoss=${stopLoss}`);
                
                const data = await response.json();
                
                if (!data.success) {
                    showError(data.message || 'Failed to load chart data');
                    return;
                }

                // Render custom candlestick chart
                renderCandlestickChart(data.candles, data.tradeInfo);

            } catch (error) {
                console.error('Error loading chart:', error);
                showError('Failed to load chart. Please try again.');
            }
        }

        function renderCandlestickChart(candles, tradeInfo) {
            const canvas = document.getElementById('candleChartCanvas');
            const ctx = canvas.getContext('2d');
            const container = canvas.parentElement;
            
            // Get device pixel ratio for crisp rendering
            const dpr = window.devicePixelRatio || 1;
            
            // Set canvas size with device pixel ratio
            const rect = container.getBoundingClientRect();
            const containerWidth = rect.width;
            const containerHeight = rect.height;
            
            canvas.width = containerWidth * dpr;
            canvas.height = containerHeight * dpr;
            canvas.style.width = containerWidth + 'px';
            canvas.style.height = containerHeight + 'px';
            
            // Scale context for device pixel ratio
            ctx.scale(dpr, dpr);
            
            if (candles.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No candle data available', containerWidth / 2, containerHeight / 2);
                return;
            }

            // Chart dimensions (using actual container size, not scaled)
            const padding = { top: 40, right: 120, bottom: 60, left: 90 };
            const chartWidth = containerWidth - padding.left - padding.right;
            const chartHeight = containerHeight - padding.top - padding.bottom;

            // Collect all prices to determine range (candles + trade lines)
            const allPrices = [];
            candles.forEach(c => {
                allPrices.push(c.low, c.high, c.open, c.close);
            });
            
            // Add trade line prices
            if (tradeInfo.entryPrice) allPrices.push(tradeInfo.entryPrice);
            if (tradeInfo.exitPrice) allPrices.push(tradeInfo.exitPrice);
            if (tradeInfo.target) allPrices.push(tradeInfo.target);
            if (tradeInfo.stopLoss) allPrices.push(tradeInfo.stopLoss);
            if (tradeInfo.dailyHigh) allPrices.push(tradeInfo.dailyHigh);
            if (tradeInfo.dailyLow) allPrices.push(tradeInfo.dailyLow);

            // Find price range including all prices
            let minPrice = Math.min(...allPrices);
            let maxPrice = Math.max(...allPrices);
            
            // Ensure minimum range to avoid division by zero
            const priceRange = maxPrice - minPrice;
            if (priceRange === 0 || priceRange < maxPrice * 0.001) {
                // If range is too small, add 1% padding on both sides
                const center = (minPrice + maxPrice) / 2;
                const padding = Math.max(center * 0.01, 0.1);
                minPrice = center - padding;
                maxPrice = center + padding;
            } else {
                // Add 5% padding to price range
                const padding = priceRange * 0.05;
                minPrice -= padding;
                maxPrice += padding;
            }

            // Calculate candle width
            const candleWidth = Math.max(2, chartWidth / candles.length * 0.8);
            const candleSpacing = chartWidth / candles.length;

            // Price to Y coordinate conversion
            function priceToY(price) {
                if (maxPrice === minPrice) return padding.top + chartHeight / 2;
                return padding.top + chartHeight - ((price - minPrice) / (maxPrice - minPrice)) * chartHeight;
            }

            // Time to X coordinate conversion
            function timeToX(index) {
                if (candles.length === 0) return padding.left;
                return padding.left + index * candleSpacing + candleSpacing / 2;
            }

            // Clear canvas (using actual dimensions)
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, containerWidth, containerHeight);

            // Draw grid lines
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const price = minPrice + (maxPrice - minPrice) * (i / 5);
                const y = priceToY(price);
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + chartWidth, y);
                ctx.stroke();
                
                // Price labels with better formatting
                ctx.fillStyle = '#666';
                ctx.font = '11px Arial';
                ctx.textAlign = 'right';
                const priceText = price.toFixed(2);
                ctx.fillText(`‚Çπ${priceText}`, padding.left - 10, y + 4);
            }

            // Draw time labels (show every 60th candle or at start/middle/end)
            const labelInterval = Math.max(1, Math.floor(candles.length / 5));
            for (let i = 0; i < candles.length; i += labelInterval) {
                const x = timeToX(i);
                const time = new Date(candles[i].timestamp);
                const timeStr = time.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                ctx.fillStyle = '#666';
                ctx.font = '11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(timeStr, x, containerHeight - padding.bottom + 20);
            }

            // Draw candlesticks
            candles.forEach((candle, index) => {
                const x = timeToX(index);
                const openY = priceToY(candle.open);
                const closeY = priceToY(candle.close);
                const highY = priceToY(candle.high);
                const lowY = priceToY(candle.low);
                
                const isBullish = candle.close >= candle.open;
                
                // Draw wick
                ctx.strokeStyle = isBullish ? '#26a69a' : '#ef5350';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, highY);
                ctx.lineTo(x, lowY);
                ctx.stroke();
                
                // Draw body
                const bodyHeight = Math.abs(closeY - openY) || 1;
                ctx.fillStyle = isBullish ? '#26a69a' : '#ef5350';
                ctx.fillRect(x - candleWidth / 2, Math.min(openY, closeY), candleWidth, bodyHeight);
                
                // Draw border
                ctx.strokeStyle = isBullish ? '#26a69a' : '#ef5350';
                ctx.strokeRect(x - candleWidth / 2, Math.min(openY, closeY), candleWidth, bodyHeight);
            });

            // Draw horizontal lines
            const lineColors = {
                entry: '#2196F3',
                exit: '#FF9800',
                target: '#4CAF50',
                stopLoss: '#F44336',
                dailyHigh: '#9C27B0',
                dailyLow: '#9C27B0'
            };

            const lines = [];
            if (tradeInfo.entryPrice) {
                lines.push({ price: tradeInfo.entryPrice, color: lineColors.entry, label: 'Entry Price', style: 'solid' });
            }
            if (tradeInfo.exitPrice) {
                lines.push({ price: tradeInfo.exitPrice, color: lineColors.exit, label: 'Exit Price', style: 'solid' });
            }
            if (tradeInfo.target) {
                lines.push({ price: tradeInfo.target, color: lineColors.target, label: 'Target', style: 'dashed' });
            }
            if (tradeInfo.stopLoss) {
                lines.push({ price: tradeInfo.stopLoss, color: lineColors.stopLoss, label: 'Stop Loss', style: 'dashed' });
            }
            if (tradeInfo.dailyHigh) {
                lines.push({ price: tradeInfo.dailyHigh, color: lineColors.dailyHigh, label: 'Day High', style: 'dotted' });
            }
            if (tradeInfo.dailyLow) {
                lines.push({ price: tradeInfo.dailyLow, color: lineColors.dailyLow, label: 'Day Low', style: 'dotted' });
            }

            lines.forEach(line => {
                const y = priceToY(line.price);
                ctx.strokeStyle = line.color;
                ctx.lineWidth = 2;
                
                if (line.style === 'dashed') {
                    ctx.setLineDash([5, 5]);
                } else if (line.style === 'dotted') {
                    ctx.setLineDash([2, 2]);
                } else {
                    ctx.setLineDash([]);
                }
                
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + chartWidth, y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Label with better formatting
                ctx.fillStyle = line.color;
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'left';
                const priceText = line.price.toFixed(2);
                ctx.fillText(`${line.label}: ‚Çπ${priceText}`, padding.left + chartWidth + 10, y + 4);
            });

            // Draw entry/exit markers
            if (tradeInfo.entryTime && candles.length > 0) {
                const entryTime = new Date(tradeInfo.entryTime);
                const entryIndex = candles.findIndex(c => new Date(c.timestamp) >= entryTime);
                if (entryIndex >= 0) {
                    const x = timeToX(entryIndex);
                    const y = priceToY(tradeInfo.entryPrice);
                    ctx.fillStyle = lineColors.entry;
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            if (tradeInfo.exitTime && candles.length > 0) {
                const exitTime = new Date(tradeInfo.exitTime);
                const exitIndex = candles.findIndex(c => new Date(c.timestamp) >= exitTime);
                if (exitIndex >= 0) {
                    const x = timeToX(exitIndex);
                    const y = priceToY(tradeInfo.exitPrice);
                    ctx.fillStyle = lineColors.exit;
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            // Draw border (using actual dimensions)
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.strokeRect(padding.left, padding.top, chartWidth, chartHeight);
            
            // Draw title
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Price', padding.left - 80, padding.top - 10);
            
            // Draw axis labels
            ctx.fillStyle = '#666';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Time', containerWidth / 2, containerHeight - 10);

            // Update legend
            const legend = document.getElementById('chartLegend');
            legend.innerHTML = lines.map(line => {
                let borderStyle = 'solid';
                if (line.style === 'dashed') {
                    borderStyle = 'dashed';
                } else if (line.style === 'dotted') {
                    borderStyle = 'dotted';
                }
                return `
                    <div class="legend-item">
                        <div class="legend-color" style="background: ${line.color}; border: 2px ${borderStyle} ${line.color};"></div>
                        <span>${line.label}</span>
                    </div>
                `;
            }).join('');
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const chartContainer = document.getElementById('candleChartContainer');
            if (allTradesData && chartContainer.style.display !== 'none') {
                const tradeSelector = document.getElementById('tradeSelector');
                const selectedIndex = parseInt(tradeSelector.value);
                if (!isNaN(selectedIndex) && allTradesData[selectedIndex]) {
                    // Small delay to ensure container size is updated
                    setTimeout(() => {
                        loadCandleChart(allTradesData[selectedIndex]);
                    }, 50);
                }
            }
        });

        // Handle ESC key to exit fullscreen
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const chartContainer = document.getElementById('candleChartContainer');
                if (chartContainer.classList.contains('fullscreen')) {
                    toggleFullscreen();
                }
            }
        });

        // Form submission
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            hideMessages();

            // Get form values before any validation
            const startDateValue = document.getElementById('startDate').value;
            const endDateValue = document.getElementById('endDate').value;
            const stockNameValue = document.getElementById('stockName').value.trim();
            const securityIdValue = document.getElementById('securityId').value.trim();
            const targetPercentValue = document.getElementById('targetPercent').value;
            const stopLossPercentValue = document.getElementById('stopLossPercent').value;
            const capitalValue = document.getElementById('capital').value;

            // Check if required fields are filled
            if (!startDateValue || !endDateValue || !stockNameValue || !securityIdValue || !targetPercentValue || !stopLossPercentValue || !capitalValue) {
                showError('Please fill in all required fields');
                return;
            }

            // Validate dates
            if (!validateDates(true)) {
                return;
            }

            // Validate numeric fields
            const targetPercent = parseFloat(targetPercentValue);
            const stopLossPercent = parseFloat(stopLossPercentValue);
            const capital = parseFloat(capitalValue);

            if (isNaN(targetPercent) || targetPercent <= 0 || targetPercent > 10) {
                showError('Target percent must be a number between 0.01 and 10');
                return;
            }

            if (isNaN(stopLossPercent) || stopLossPercent <= 0 || stopLossPercent > 10) {
                showError('Stop loss percent must be a number between 0.01 and 10');
                return;
            }

            if (isNaN(capital) || capital < 1000) {
                showError('Capital must be a number greater than or equal to 1000');
                return;
            }

            const formData = {
                stockName: stockNameValue,
                securityId: securityIdValue,
                startDate: startDateValue,
                endDate: endDateValue,
                targetPercent: targetPercent,
                stopLossPercent: stopLossPercent,
                capital: capital
            };

            showLoading();

            try {
                const response = await fetch('/strategy/run', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                });

                const data = await response.json();

                if (data.success) {
                    displayResults(data);
                } else {
                    showError(data.message || 'An error occurred while running the strategy');
                }

            } catch (error) {
                console.error('Error:', error);
                showError('Network error. Please check your connection and try again.');
            } finally {
                hideLoading();
            }
        });
    </script>
</body>
</html>

